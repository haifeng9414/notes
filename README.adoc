= 学习笔记
:hardbreaks:
 
== 消息队列
[qanda]
消息队列能解决什么问题::
+
[%collapsible]
====
. 异步处理
  
  不用等待所有动作都执行完成，只需要完成必要的动作，如风险控制和锁定库存操作是必须的，但是生成订单和短信通知等动作可
  以异步操作，这样能够更快的返回请求结果
  
  异步请求使得非必要的动作可以并发执行，如上面说的生成订单和发送短信通知，提高了系统性能

. 流量控制

  请求到达网关后先保存到消息队列，后台服务再从消息队列获取请求，使得消息队列隔离了网关和后台服务，达到了”削峰“的目的

  在网关添加流量控制逻辑，如使用令牌桶算法，令牌生成器按照固定速率向消息队列生成令牌，网关处理请求时消费令牌，流量控
  制实现在网关，对后台服务无侵入，降低了系统复杂度

. 服务解耦
. 实现服务之间的观察者模式
. 消息广播
====
+

消息队列带来什么问题::
+
[%collapsible]
====
. 可用性降低，消息队列挂掉后可能会影响多个其他服务
. 增加了系统的复杂度，需要考虑消息丢失、重复消费、消息顺序等问题
. 数据不一致问题，如何保证发送消息和消费消息的原子性
====
+


== Linux
[qanda]
inode相关::
+
[%collapsible]
====
. 概念
硬盘的最小存储单位叫做"扇区"（Sector），每个扇区储存512字节。
操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个"块"（block）
，这种由多个扇区组成的"块"，是文件存取的最小单位。"块"的大小，最常见的是4KB，即连续八个sector组成一个block。
文件数据都储存在"块"中，必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存
文件元信息的区域就叫做inode，中文译名为"索引节点"
每一个文件都有对应的inode，里面包含了与该文件有关的一些信息，包括：
* 文件的字节数
* 文件拥有者的User ID
* 文件的Group ID
* 文件的读、写、执行权限
* 文件的时间戳，共有三个：ctime指inode上一次变动的时间，mtime指文件内容上一次变动的时间，atime指文件上一次打开的
时间。
* 链接数，即有多少文件名指向这个inode
* 文件数据block的位置
可以用``stat``命令查看文件的inode信息，如：
+
----
[root@centos-7 ~]# stat makefile 
  文件："makefile"
  大小：71        	块：8          IO 块：4096   普通文件
设备：fd00h/64768d	Inode：100670496   硬链接：1
权限：(0644/-rw-r--r--)  Uid：(    0/    root)   Gid：(    0/    root)
环境：unconfined_u:object_r:admin_home_t:s0
最近访问：2018-10-24 05:35:11.667000000 +0800
最近更改：2018-10-24 05:35:11.010000000 +0800
最近改动：2018-10-24 05:35:11.011000000 +0800
创建时间：-
----
+

inode也会消耗硬盘空间，所以硬盘格式化的时候，操作系统自动将硬盘分成两个区域。一个是数据区，存放文件数据；另一个是
inode区（inode table），存放inode所包含的信息。
每个inode节点的大小，一般是128字节或256字节。inode节点的总数，在格式化时就给定，一般是每1KB或每2KB就设置一个
inode。假定在一块1GB的硬盘中，每个inode节点的大小为128字节，每1KB就设置一个inode，那么inode table的大小就会达
到128MB，占整块硬盘的12.8%。
查看每个硬盘分区的inode总数和已经使用的数量，可以使用df命令：
+
----
[root@centos-7 ~]# df -i
文件系统                   Inode 已用(I)  可用(I) 已用(I)% 挂载点
/dev/mapper/centos-root 21487616   51118 21436498       1% /
devtmpfs                  231797     380   231417       1% /dev
tmpfs                     234810       1   234809       1% /dev/shm
tmpfs                     234810     579   234231       1% /run
tmpfs                     234810      16   234794       1% /sys/fs/cgroup
/dev/sda1                 524288     327   523961       1% /boot
/dev/mapper/centos-home 10489856       3 10489853       1% /home
tmpfs                     234810       1   234809       1% /run/user/0
----
+

每个inode都有一个号码，操作系统用inode号码来识别不同的文件。
Unix/Linux系统内部不使用文件名，而使用inode号码来识别文件。对于系统来说，文件名只是inode号码便于识别的别称或者绰
号。
表面上，用户通过文件名，打开文件。实际上，系统内部这个过程分成三步：首先，系统找到这个文件名对应的inode号码；其次，
通过inode号码，获取inode信息；最后，根据inode信息，找到文件数据所在的block，读出数据。
使用ls -i命令，可以看到文件名对应的inode号码：
+
----
[root@centos-7 ~]# ls -i makefile 
100670496 makefile
----
+

Unix/Linux系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。
目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：所包含文件的文件名，以及该文件名
对应的inode号码。
ls命令只列出目录文件中的所有文件名，ls -i命令列出整个目录文件，即文件名和inode号码：
+
----
[root@centos-7 ~]# ls -i
100663394 anaconda-ks.cfg  100670496 makefile  100663751 mysql57-community-release-el7-11.noarch.rpm  100670473 percona-release-latest.noarch.rpm
----
+

目录文件的读权限（r）和写权限（w），都是针对目录文件本身。由于目录文件内保存文件名和inode号码，所以如果有读权限，就
能够获取目录内的文件名，如果具有写权限就能在目录中创建文件，如果具有执行权限，就能cd到目录，如：

** dhf用户没有``/tmp/test``的读权限，无法获取目录内文件列表
+
----
[dhf@centos-7 ~]$ ls -l /tmp
total 0
drw-------. 2 root root 6 Nov 28 18:15 test
[dhf@centos-7 ~]$ ls -l /tmp/test
ls: cannot open directory /tmp/test: Permission denied
----
+

** dhf用户有``/tmp/test``的读权限，可以获取该目录下的文件列表，但是没有该目录下文件的执行权限，无法获取文件详情，
也无法进入目录
+
----
[dhf@centos-7 ~]$ ls -ld /tmp/test
drw-r--r--. 2 root root 22 Nov 28 18:20 /tmp/test
[dhf@centos-7 ~]$ ls /tmp/test
ls: cannot access /tmp/test/file.txt: Permission denied
file.txt
[dhf@centos-7 ~]$ cd /tmp/test
-bash: cd: /tmp/test: Permission denied
----
+

** dhf用户有``/tmp/test``的读和执行权限，可以获取该目录下的文件列表、获取文件详情和进入目录，但是无法创建文件
+
----
[dhf@centos-7 ~]$ ls -ld /tmp/test/
dr-xr-xr-x. 2 root root 22 Nov 28 18:20 /tmp/test/
[dhf@centos-7 ~]$ cd /tmp/test/
[dhf@centos-7 test]$ ls
file.txt
[dhf@centos-7 test]$ ls -i file.txt 
67431434 file.txt
[dhf@centos-7 test]$ touch dhf
touch: cannot touch ‘dhf’: Permission denied
----
+

** 想要在目录下创建文件，必须有写权限（因为需要在目录文件写创建的文件名和inode号码）和执行权限
+
----
[dhf@centos-7 ~]$ ls -ld /tmp/test/
drwxrwxrwx. 2 root root 22 Nov 28 18:20 /tmp/test/
[dhf@centos-7 ~]$ cd /tmp/test/
[dhf@centos-7 test]$ touch dhf
[dhf@centos-7 test]$ ll -ah
total 0
drwxrwxrwx. 2 root root  33 Nov 28 18:33 .
drwxrwxrwt. 8 root root 105 Nov 28 18:15 ..
-rw-rw-r--. 1 dhf  dhf    0 Nov 28 18:33 dhf
-rw-r--r--. 1 root root   0 Nov 28 18:20 file.txt
----
+

. 硬链接
一般情况下，文件名和inode号码是"一一对应"关系，每个inode号码对应一个文件名。但是，Unix/Linux系统允许，多个文件名
指向同一个inode号码。
这意味着，可以用不同的文件名访问同样的内容；对文件内容进行修改，会影响到所有文件名；但是，删除一个文件名，不影响另一
个文件名的访问。这种情况就被称为"硬链接"（hard link），ln命令可以创建硬链接：
+
----
[root@centos-7 tmp]# ls -l
总用量 0
-rw-r--r--. 1 root root 0 11月 28 18:50 file1.txt
[root@centos-7 tmp]# ln file1.txt file2.txt 
[root@centos-7 tmp]# ls -l
总用量 0
-rw-r--r--. 2 root root 0 11月 28 18:50 file1.txt
-rw-r--r--. 2 root root 0 11月 28 18:50 file2.txt
----
+
运行上面这条命令以后，源文件与目标文件的inode号码相同，都指向同一个inode。inode信息中有一项叫做"链接数"，记录指向
该inode的文件名总数，这时就会增加1。
反过来，删除一个文件名，就会使得inode节点中的"链接数"减1。当这个值减到0，表明没有文件名指向这个inode，系统就会回收
这个inode号码，以及其所对应block区域。
创建目录时，默认会生成两个目录项："."和".."。前者的inode号码就是当前目录的inode号码，等同于当前目录的"硬链接"；后
者的inode号码就是当前目录的父目录的inode号码，等同于父目录的"硬链接"。所以，任何一个目录的"硬链接"总数，总是等于2
加上它的子目录总数（含隐藏目录）。

. 软链接
当使用软链接时，文件A和文件B的inode号码不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文
件B。因此，无论打开哪一个文件，最终读取的都是文件B。这时，文件A就称为文件B的"软链接"（soft link）或者"符号链接
（symbolic link）。
这意味着，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错："No such file or directory"。这是软链接与
硬链接最大的不同：文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode"链接数"不会因此发生变化。
ln -s命令可以创建软链接：
+
----
[root@centos-7 tmp]# ls -l
总用量 0
-rw-r--r--. 1 root root 0 11月 28 18:50 file1.txt
[root@centos-7 tmp]# ln -s file1.txt file2.txt 
[root@centos-7 tmp]# ls -l
总用量 0
-rw-r--r--. 1 root root 0 11月 28 18:50 file1.txt
lrwxrwxrwx. 1 root root 9 11月 28 18:56 file2.txt -> file1.txt
----
+
====
+